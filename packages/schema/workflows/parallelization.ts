/**
 * Parallelization Workflow Pattern
 *
 * Splits a task into subtasks, executes them in parallel, and merges results.
 *
 * Pattern:
 *   Input → Split → Parallel execution → Merge → Output
 *
 * Use when:
 * - Task can be decomposed into independent subtasks
 * - Subtasks don't depend on each other
 * - Speed is important (parallel execution)
 */

import type { Workflow } from './workflow'

/**
 * A subtask generated by the split phase
 */
export interface Subtask {
  /** Unique identifier for this subtask */
  id: string
  /** The prompt/input for this subtask */
  prompt: string
  /** Optional metadata for the subtask */
  metadata?: Record<string, unknown>
}

/**
 * Result from a parallel subtask execution
 */
export interface SubtaskResult<T = unknown> {
  /** ID of the subtask */
  id: string
  /** Whether execution succeeded */
  success: boolean
  /** The result data (if successful) */
  data?: T
  /** Error message (if failed) */
  error?: string
  /** Execution time in milliseconds */
  durationMs?: number
}

/**
 * Parallelization workflow that splits, executes in parallel, and merges
 *
 * @template Output - The type of final merged result
 */
export interface ParallelizationWorkflow<Output> extends Workflow<Output> {
  /**
   * Split the input prompt into parallelizable subtasks
   *
   * @param prompt - The input to split
   * @returns Promise resolving to array of subtasks
   */
  split(prompt: string): Promise<Subtask[]>

  /**
   * Execute subtasks in parallel
   *
   * @param subtasks - The subtasks to execute
   * @returns Promise resolving to array of results (in same order as subtasks)
   */
  parallel(subtasks: Subtask[]): Promise<SubtaskResult[]>

  /**
   * Merge parallel results into a single output
   *
   * @param results - Results from all parallel executions
   * @returns Promise resolving to the merged output
   */
  merge(results: SubtaskResult[]): Promise<Output>
}

/**
 * Configuration for parallelization workflow
 */
export interface ParallelizationConfig {
  /** Maximum number of concurrent executions */
  maxConcurrency?: number
  /** Strategy for handling failures */
  failureStrategy?: 'fail-fast' | 'collect-all'
  /** Whether to include failed results in merge */
  includeFailures?: boolean
}
