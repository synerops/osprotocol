/**
 * Orchestrator-Workers Workflow Pattern
 *
 * A central orchestrator breaks down tasks, delegates to specialized workers,
 * and synthesizes their results into a final output.
 *
 * Pattern:
 *   Input → Plan → Delegate to workers → Collect results → Synthesize → Output
 *
 * Use when:
 * - Task requires multiple specialized capabilities
 * - Subtasks can be processed independently
 * - Results need to be aggregated intelligently
 */

import type { Workflow } from './workflow'

/**
 * A step in the execution plan
 */
export interface PlanStep {
  /** Unique identifier for this step */
  id: string
  /** Description of what this step accomplishes */
  description: string
  /** The worker/agent to delegate this step to */
  worker: string
  /** Input data for this step */
  input: string
  /** IDs of steps that must complete before this step */
  dependsOn?: string[]
}

/**
 * Execution plan generated by the orchestrator
 */
export interface Plan {
  /** Ordered list of steps to execute */
  steps: PlanStep[]
  /** Overall goal of the plan */
  goal: string
}

/**
 * Result from a worker execution
 */
export interface WorkerResult<T = unknown> {
  /** ID of the step that produced this result */
  stepId: string
  /** The worker that executed the step */
  worker: string
  /** Whether execution succeeded */
  success: boolean
  /** The result data (if successful) */
  data?: T
  /** Error message (if failed) */
  error?: string
}

/**
 * Orchestrator-Workers workflow that plans, delegates, and synthesizes
 *
 * @template Output - The type of final synthesized result
 */
export interface OrchestratorWorkersWorkflow<Output> extends Workflow<Output> {
  /**
   * Generate an execution plan for the given prompt
   *
   * @param prompt - The input task to plan
   * @returns Promise resolving to the execution plan
   */
  plan(prompt: string): Promise<Plan>

  /**
   * Delegate a plan step to the appropriate worker
   *
   * @param step - The plan step to execute
   * @returns Promise resolving to the worker's result
   */
  delegate(step: PlanStep): Promise<WorkerResult>

  /**
   * Synthesize worker results into a final output
   *
   * @param results - Results from all worker executions
   * @param plan - The original execution plan
   * @returns Promise resolving to the synthesized output
   */
  synthesize(results: WorkerResult[], plan: Plan): Promise<Output>
}

/**
 * Worker registration for the orchestrator
 */
export interface WorkerConfig {
  /** Unique identifier for this worker */
  name: string
  /** Description of the worker's capabilities */
  description: string
  /** The workflow this worker uses */
  workflow: Workflow<unknown>
  /** Types of tasks this worker can handle */
  capabilities: string[]
}
